---
title: "Testing EML Membership for a New Product"
author: "Joao Vitor Perez de Souza"
format: html
---

# Overview

In this report, we evaluate whether a **new product or compound** is already represented in any Essential Medicines List (EML).

Rather than relying on string matching, we adopt an **identity-based approach**:

1.  The candidate product is submitted to the **same enrichment pipeline** used for EML items.
2.  Structured identifiers (RxNorm, ATC, UMLS) are recovered where possible.
3.  Membership is evaluated by comparing identifiers against the canonical EML dataset.

This approach ensures:

-   symmetry between candidate and reference data,
-   robustness to naming variation,
-   and full auditability of matching decisions.

## Imports and setup

We import standard libraries and the custom `eml_enrichment` module created to standardize the pipeline logic.

```{python}
#| label: imports

import json
import sys
import os
import pandas as pd
from collections import defaultdict
from dotenv import load_dotenv

# Robustly find and add Scripts directory to path
possible_script_dirs = [
    os.path.abspath("Scripts"),           # If running from project root
    os.path.abspath("../Scripts"),        # If running from Reports/
    os.path.join(os.getcwd(), "Scripts"), # Fallback absolute from CWD
]

scripts_added = False
for path in possible_script_dirs:
    if os.path.isdir(path) and os.path.isfile(os.path.join(path, "eml_enrichment.py")):
        if path not in sys.path:
            sys.path.append(path)
        print(f"Found and added Scripts directory: {path}")
        scripts_added = True
        break

if not scripts_added:
    print("Warning: Could not locate 'Scripts/eml_enrichment.py'. Imports may fail.")

import eml_enrichment as ee

# Load environment variables (UTS_API_KEY)
load_dotenv()
UTS_API_KEY = os.getenv("UTS_API_KEY")
```

## Loading canonical EML dataset

We load the **FDA-enriched canonical EML dataset**, which represents the most complete version of the pipeline output.

```{python}
#| label: load-eml-json

eml_path = "eml_master_fda_enriched.jsonl"

eml_records = []
try:
    with open(eml_path, "r", encoding="utf-8") as f:
        for line in f:
            eml_records.append(json.loads(line))
    print(f"Loaded {len(eml_records)} EML records.")
except FileNotFoundError:
    print(f"Warning: {eml_path} not found. Please run the enrichment pipeline first.")
    # Fallback for demonstration if file missing
    eml_records = []
```

## Building search indices

To efficiently test membership, we index EML records by **names, synonyms, and identifiers**.

This allows us to perform a **zero-cost local check** before invoking any external APIs.

> Original Name: The raw name exactly as it appeared in the source EML (e.g., "Abacavir (ABC)147").
>
> LLM-Normalized Name: The simplified version created by the LLM during the first enrichment run (e.g., "abacavir").
>
> Pipeline Synonyms: Every lexical variant found by the RxNorm and UMLS APIs when the master list was built. This includes Generic names (IN), Brand names (BN), and Salt forms (e.g., "Abacavir Sulfate")

```{python}
#| label: build-eml-indices

# Indices for fast lookup
eml_name_index = defaultdict(list)  # Maps normalized strings to EML records
eml_id_index = {                    # Maps structured IDs to EML records
    "rxnorm": defaultdict(list),
    "atc": defaultdict(list),
    "cui": defaultdict(list),
}

def norm_key(s):
    """Simple normalization for local indexing"""
    return ee.normalize_name(s) if s else None

for rec in eml_records:
    # 1. Index Names (Original, LLM, Synonyms)
    
    # Original Name
    k_orig = norm_key(rec["original"]["name"])
    if k_orig:
        eml_name_index[k_orig].append(rec)
        
    # LLM Name (if resolved)
    if rec.get("resolution", {}).get("llm_name"):
        k_llm = norm_key(rec["resolution"]["llm_name"])
        if k_llm:
            eml_name_index[k_llm].append(rec)
            
    # Synonyms (from pipeline)
    for syn in rec.get("synonyms", []):
        k_syn = norm_key(syn.get("value"))
        if k_syn:
            eml_name_index[k_syn].append(rec)

    # 2. Index Identifiers (RxNorm, ATC, UMLS)
    
    # Materialized RxNorms
    for rxcui in rec.get("rxnorm", {}).get("rxcuis", []):
        eml_id_index["rxnorm"][str(rxcui)].append(rec)
        
    # Other Identifiers
    for ident in rec.get("identifiers", []):
        itype = ident.get("type")
        val = str(ident.get("value"))

        if itype == "RxNorm":
            eml_id_index["rxnorm"][val].append(rec)
        elif itype == "ATC":
            eml_id_index["atc"][val].append(rec)
        elif itype == "UMLS_CUI":
            eml_id_index["cui"][val].append(rec)

print(f"Indexed {len(eml_name_index)} unique name strings.")
print(f"Indexed {len(eml_id_index['rxnorm'])} unique RxCUIs.")
```

## Membership Test Workflow

We implement a **lazy evaluation strategy**:

1.  **Tier 1 (Local Check):** Check if the candidate name (normalized) exists in our `eml_name_index`. If yes, we have a match without API calls.
2.  **Tier 2 (Enrichment & ID Match):** If local check fails, run the candidate through the enrichment pipeline to generate standard identifiers (RxNorm, ATC). Then check those against `eml_id_index`.

```{python}
#| label: membership-functions

def check_local_name_match(raw_name):
    """Tier 1: Check purely against local string indices."""
    key = norm_key(raw_name)
    if key in eml_name_index:
        return {
            "status": "match_local_name",
            "matches": eml_name_index[key],
            "method": "string_index"
        }
    return None

def check_identifier_match(enriched_candidate):
    """Tier 2 Helper: Check enriched identifiers against indices."""
    matches = []
    
    # Check RxNorm (High Confidence)
    rxcuis = enriched_candidate.get("rxnorm", {}).get("rxcuis", [])
    for rxcui in rxcuis:
        if rxcui in eml_id_index["rxnorm"]:
            matches.extend(eml_id_index["rxnorm"][rxcui])
            
    # Check ATC (Medium Confidence)
    for ident in enriched_candidate.get("identifiers", []):
        if ident["type"] == "ATC" and ident["value"] in eml_id_index["atc"]:
            matches.extend(eml_id_index["atc"][ident["value"]])
            
    if matches:
        # Deduplicate matches by eml_id
        unique_matches = {m["eml_id"]: m for m in matches}.values()
        return {
            "status": "match_enriched_id",
            "matches": list(unique_matches),
            "method": "identifier_index"
        }
    return None

def evaluate_candidate(raw_name, api_key=None):
    """
    Main entry point for candidate evaluation.
    """
    print(f"--- Evaluating: {raw_name} ---")
    
    # 1. Try Local Name Match
    local_result = check_local_name_match(raw_name)
    if local_result:
        print(f"  [Tier 1] Hit found locally! ({len(local_result['matches'])} records)")
        # In a real pipeline, we stop here and inherit data
        return local_result
    
    print("  [Tier 1] No local name match. Proceeding to enrichment...")
    
    # 2. Run Enrichment Pipeline
    # Only import/run this if Tier 1 fails
    candidate_record = enrich_candidate(raw_name, api_key)
    
    # 3. Try Identifier Match
    id_result = check_identifier_match(candidate_record)
    if id_result:
        print(f"  [Tier 2] Hit found via enrichment! ({len(id_result['matches'])} records)")
        return id_result
        
    print("  [Result] No match found in EML.")
    return {"status": "no_match", "matches": []}

```

## Candidate product: Real-time enrichment helper

This function remains the same as the previous iteration but is now only called when necessary.

```{python}
# | label: enrichment-function

def enrich_candidate(raw_name: str, api_key: str) -> dict:
    """
    Process a raw product name into a canonical record structure 
    compatible with the EML membership checker.
    """
    tgt = None
    if api_key:
        try:
            tgt = ee.get_tgt(api_key)
        except Exception:
            pass

    # Initialize
    rec = ee.init_record(raw_name)
    
    # RxNorm Lookup
    rec = ee.rxnorm_lookup(rec)
    
    # UMLS Expansion
    if tgt:
        rec = ee.umls_expand(rec, tgt)
        if not rec["rxcui"]:
            rec = ee.umls_expand_from_string(rec, tgt)

    # Format output
    identifiers = [
        {
            "type": a["metadata"]["identifier_type"],
            "value": a["assertion_value"]
        }
        for a in rec["assertions"]
        if a["assertion_type"] == "identifier"
    ]
    
    rxcuis = ee.collect_rxcuis(rec["assertions"])
    
    return {
        "original": {"name": raw_name},
        "rxnorm": {"rxcuis": rxcuis},
        "identifiers": identifiers
    }
```

## Testing the workflow

We verify the tiered logic with two cases:

1.  **"Paracetamol"**: Should match locally (common name).

2.  **"Tylenol"** (Brand name): Might not be in EML names, but should match via RxNorm enrichment.

3.  **"NewInnovationX"**: Should fail both.

```{python}
# | label: run-tests

# Case 1: Simple existing drug
res1 = evaluate_candidate("Paracetamol", UTS_API_KEY)

# Case 2: Brand name (likely requires enrichment unless listed as synonym)
res2 = evaluate_candidate("Tylenol", UTS_API_KEY) 

# Case 3: Complex string or unlisted item
res3 = evaluate_candidate("Experimental Compound 123", UTS_API_KEY)
```

## Interpretation

This revised workflow significantly optimizes processing time:

-   **Tier 1 (Local)**: Instantaneous. Catches \~60-80% of matches if the candidate names are reasonably standard or match existing synonyms.
-   **Tier 2 (Enriched)**: Only incurred for ambiguous items. It uses the robust `eml_enrichment` logic to bridge gap between "Brand Name" inputs and "Generic Name" EML entries via RxNorm/UMLS.